#! /usr/bin/python

# Script that generates a planar circle using the analytical function of sines and cosines
# This includes calculating the step params, convert to reference frames, add global frame as the new last base pair, converting back to step params, and output X.par file
 
import os, math, argparse
import numpy as np
import pandas as pd
path = os.getcwd()

# --- CLI goal: 
# $ python3 SCRIPT.py -l       ... -r     ... -t            ... -s    ... -o       ...
# $ python3 SCRIPT.py --length ... --rise ... --bp-per-turn ... --seq ... --output-name ...

parser = argparse.ArgumentParser(prog="Planar Circle Generator",
                                 description="Generate a 3DNA-formatted parameter file associated with a planar circle of DNA using trigonometric functions.\nCode Generated by Robert Young, Rutgers University, 2021\n", 
                                 epilog="Mathematics citation: TBA.\nCode Generated by Robert Young, Rutgers University, 2021\n")
parser.add_argument('--length', '-l', action='store', 
                    type=int, required=True, dest="length", 
                    help="Length of DNA\n")
parser.add_argument('--seq','-s', action='store',
                    type=argparse.FileType('r'), default=None, dest="sequence", 
                    help="Reads a text file that contains the base pair sequence (default is a string of A residues that spans the specified length).\nAcceptable formats include text files with either a single line of the capitalized bases in sequence with no spaces or a sequence that has been copied from PubMed.\nEnsure that the sequence document does not contain non-sequence information (e.g. header, gene name(s), errata).\n")
parser.add_argument('--rise','-r', action='store',
                    type=float, default=3.40000, dest="rise", 
                    help="Rise displacement between successive base pairs (default=3.4-Angstrom, for B-DNA)\n")
parser.add_argument('--bp-per-turn','-t', action='store',
                    type=float, default=10.5, dest="bases_per_turn", 
                    help="Number of base pairs in a helical turn (default=10.5)\n")
parser.add_argument('--output-name','-o', action='store',
                    type=str, default="pcirc", dest="filename", 
                    help="Output name of parameter file (default=pcirc).\n-!- File extension has already been set to .par\n")
args= parser.parse_args()


# --- MAIN ------------------------------------------------------------------------------------------------------------
def main():
    if args.sequence == None:
        SEQ = 'A'*args.length
    else:
        SEQ = sequence_input_format(args.sequence)

    if args.length != len(SEQ):
        print("\n-!- Error: Circle length (N="+str(args.length)+") does not match sequence length (N="+str(len(SEQ))+").\nMake sure the length of the desired circle matches the sequence length.\n")
        
    else:
        DF  = planar_circle(args.length, args.rise, args.bases_per_turn)
        DF2 = dataframe_pars_to_frames(DF)
        DF2 = circular_dataframe(DF2)
        DF3 = dataframe_frames_to_pars(DF2)
        params_writer(DF3, SEQ, args.filename)
        del DF, DF2, DF3


# --- SCRIPT STEP-BY-STEP TASK LIST -----------------------------------------------------------------------------------
# Step 0: Check sequence input file
def sequence_input_format(DATAFILE):
    DATA = args.sequence.readlines()
    DATA = [i.rstrip('\n').replace(' ', '').upper() for i in DATA]
    STRING = ''
    for line in DATA:
        STRING += line
    return STRING

# Step 1: calculate rotational base-pair step parameters
def planar_circle(length, rise, bases_per_turn):
    """
    - length:         The length of the desired DNA construct
    - rise:           Vertical displacement between base pairs; for B-DNA, use 3.400-Angstroms
    - bases_per_turn: The number of bases for 1 helical turn of DNA. This will be used for rotational Twist.
    * NOTE: if length / bases_per_turn (the linking number) is NOT an integer value, the ends of the circle will not smoothly connect
    - dna_sequence:   Desired nucleotide sequence; default (found in code) will be a coding strand of only adenine residues
    return a pandas dataframe of shift, slide, rise, tilt, roll, twist values
    """
    DELTA     = 360/length # The bending angle at each step along circle
    TWIST_DEG = 360/bases_per_turn
    TWIST_RAD = np.deg2rad(TWIST_DEG)
    titles = ['shift','slide','rise','tilt','roll','twist']
    
    DATAFRAME = pd.DataFrame(columns=[i for i in titles], index=[i for i in range(length)])
    DATAFRAME[['shift','slide']]=0.00000
    for i in range(length):
        if i == 0:
            DATAFRAME.at[i, ['rise','tilt','roll','twist']]=0.00000
        else:
            DATAFRAME.at[i, 'rise']  = round(float(rise), 5)
            DATAFRAME.at[i, 'twist'] = round(float(TWIST_DEG), 5)
            
            DATAFRAME.at[i, 'tilt'] = round(float(DELTA*np.sin(i*TWIST_RAD)), 5)
            DATAFRAME.at[i, 'roll'] = round(float(DELTA*np.cos(i*TWIST_RAD)), 5)
            
    del DELTA, TWIST_DEG, TWIST_RAD, titles
    return DATAFRAME


# Step 2: convert parameters to reference frames
def dataframe_pars_to_frames(DATAFRAME):
    rf_titles=['ox','oy','oz','d11','d12','d13','d21','d22','d23','d31','d32','d33']
    DATAFRAME2 = pd.DataFrame(columns=[i for i in rf_titles], index=[i for i in range(len(DATAFRAME))])
    DATAFRAME2.at[0]=[0.,0.,0.,1.,0.,0.,0.,1.,0.,0.,0.,1.]
    
    for i in range(1, len(DATAFRAME)):
        DATAFRAME2.at[i]=bp_geometry_conversion.steppar_to_frames(DATAFRAME.loc[[i]].to_numpy()[0], DATAFRAME2.loc[[i-1]].to_numpy()[0]).flatten()    
    del rf_titles
    return DATAFRAME2

# Step 3: refframe[first] = refframe[last]
def circular_dataframe(DATAFRAME):
    return DATAFRAME.append(DATAFRAME.iloc[0], ignore_index=True).reset_index(drop=True)

# Step 4: convert reference frames to parameters
def dataframe_frames_to_pars(DATAFRAME):
    pars_titles = ['shift','slide','rise','tilt','roll','twist']
    DATAFRAME2 = pd.DataFrame(columns=[i for i in pars_titles], index=[i for i in range(len(DATAFRAME))])
    DATAFRAME2.at[0]=0.
    
    for i in range(1, len(DATAFRAME)):
        DATAFRAME2.at[i]=bp_geometry_conversion.frames_to_steppar(DATAFRAME.loc[[i-1]].to_numpy()[0], DATAFRAME.loc[[i]].to_numpy()[0])
    DATAFRAME2 = DATAFRAME2.astype('float')
    del pars_titles
    return DATAFRAME2

# Step 5: output X.par file
def params_writer(DATAFRAME, SEQUENCE, OUTPUTNAME):
    '''
    Needs a 2 line header >'{:>4}'.format(str(len(PARAM_COLLECTION)))+" # base pairs\n  0 # ***local base-pair & step parameters***\n
    line format > {seq:<4} {bp1:>9} {bp2:>9} {bp3:>9} {bp4:>9} {bp5:>9} {bp6:>9} {bps1:>9} {bps2:>9} {bps3:>9} {bps4:>9} {bps5:>9} {bps6:>9}
    first line of this format must be column titles: '#','Shear','Stretch','Stagger','Buckle','Prop-Tw','Opening','Shift','Slide','Rise','Tilt','Roll','Twist'
    '''        
    PARAM_COLLECTION = DATAFRAME.to_numpy()
    SEQ = SEQUENCE+SEQUENCE[0:1]
    BPDICT={'A':'A-T', 'T':'T-A','C':'C-G','G':'G-C'}
    if len(PARAM_COLLECTION)!= len(SEQ):
        print("FAILED")
        
    else:
        with open(OUTPUTNAME+'.par', 'w') as outfile:
            outfile.write('{}'.format(str(len(PARAM_COLLECTION)-1))+" # base pairs\n    0 # ***local base-pair & step parameters***\n")
            outfile.write('{:<7} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10}\n'.format('#','Shear','Stretch','Stagger','Buckle','Prop-Tw','Opening','Shift','Slide','Rise','Tilt','Roll','Twist'))

            for i in range(len(PARAM_COLLECTION)):
                outfile.write('{seq:<7} {bp1:>10} {bp2:>10} {bp3:>10} {bp4:>10} {bp5:>10} {bp6:>10} {bps1:>10} {bps2:>10} {bps3:>10} {bps4:>10} {bps5:>10} {bps6:>10}\n'.format(
                seq = BPDICT[SEQ[i:i+1]], 
                bp1 = 0.0000, bp2=0.0000,   bp3=0.0000, 
                bp4 = 0.0000, bp5=0.0000,   bp6=0.0000, 
                bps1= round(PARAM_COLLECTION[i][0], 5), 
                bps2= round(PARAM_COLLECTION[i][1], 5),
                bps3= round(PARAM_COLLECTION[i][2], 5), 
                bps4= round(PARAM_COLLECTION[i][3], 5),
                bps5= round(PARAM_COLLECTION[i][4], 5),
                bps6= round(PARAM_COLLECTION[i][5], 5)
                ))
    del BPDICT, PARAM_COLLECTION, SEQ
    return


# ---------------------------------------------------------------------------------------------------------------------
# --- Standard Libary of Mathematics Definitions and Classes ----------------------------------------------------------
# ---------------------------------------------------------------------------------------------------------------------
        
GLOBAL_O = np.array([0.0, 0.0, 0.0])
GLOBAL_X = np.array([1.0, 0.0, 0.0])
GLOBAL_Y = np.array([0.0, 1.0, 0.0])
GLOBAL_Z = np.array([0.0, 0.0, 1.0])
GLOBAL_FRAME = [GLOBAL_O, [GLOBAL_X, GLOBAL_Y, GLOBAL_Z]]

class bp_geometry:
    #@staticmethod
    #def           

    @staticmethod
    def frame_format(FRAME):
        '''
        Turn a 1x12 array, or flattened matrix, from reference frames into a 4x3 vector, where:
        - top 1x3 is the origin
        - bottom 3x3 is the transpose of the basis vector
        '''
        if len(FRAME) != 12:
            return "-!- Error: Improperly formatted data. Check input."
        else:
            return np.array([FRAME[[0,1,2]],
                             FRAME[[3,4,5]], 
                             FRAME[[6,7,8]], 
                             FRAME[[9,10,11]]], dtype=float)    
    
    @staticmethod
    def norm_vec(vector):
        return vector/np.linalg.norm(vector)
    
    @staticmethod
    def gram_schmidt_n3(vector1, vector2, vector3):
        VECTOR1 = bp_geometry.norm_vec(vector1)
        VECTOR2 = bp_geometry.norm_vec(vector2 - np.dot(VECTOR1, vector2)*VECTOR1)
        VECTOR3 = bp_geometry.norm_vec(vector3 - np.dot(VECTOR1, vector3)*VECTOR1 - np.dot(VECTOR2, vector3)*VECTOR2)
        return np.array([VECTOR1, VECTOR2, VECTOR3])

    @staticmethod
    def vec_distance(vector):
        if len(vector) == 2:
            return np.sqrt(vector[0]**2 + vector[1]**2)
        elif len(vector) == 3:
            return np.sqrt(vector[0]**2 + vector[1]**2 + vector[2]**2)

    @staticmethod
    def vector_dot(vector1, vector2):
        return np.dot(vector1, vector2)/((np.linalg.norm(vector1))*(np.linalg.norm(vector2)))

    @staticmethod
    def vector_cross(vector1, vector2):
        '''Returns a vector of same dim as vector1 and vector2'''
        return bp_geometry.norm_vec(np.cross(vector1, 
                                             vector2))

    @staticmethod
    def vecvec_angle(vector1, vector2):
        '''Returns an angle in radians'''
        return np.arccos( np.dot(bp_geometry.norm_vec(vector1), 
                                 bp_geometry.norm_vec(vector2) ) )

    @staticmethod
    def positions_angle(positionvector1, positionvector2, positionvector3):
        '''Returns an angle in radians'''
        vec1 = bp_geometry.norm_vec(positionvector1 - positionvector2)
        vec2 = bp_geometry.norm_vec(positionvector3 - positionvector2)
        return np.arccos( np.dot(vec1, vec2) )

    @staticmethod
    def plane_normal(point1, point2, point3):
        return bp_geometry.norm_vec(np.cross(bp_geometry.norm_vec(point2 - point1),
                                             bp_geometry.norm_vec(point3 - point1)))

    @staticmethod
    def plane_projection(planenormal, vector):
        return bp_geometry.norm_vec(vector - np.dot(vector, planenormal)*planenormal)

    @staticmethod
    def vecpln_angle(vector, planenormal):
        '''Returns an angle in radians'''
        return np.arcsin( np.dot(bp_geometry.norm_vec(vector),
                                 bp_geometry.norm_vec(planenormal) ) )

    @staticmethod
    def plane_angles(planenormal1, planenormal2):
        '''Returns an angle in radians'''
        vecA = -1*(bp_geometry.norm_vec(planenormal1))
        vecB = bp_geometry.norm_vec(planenormal2)
        return np.arccos( np.dot(vecA, vecB) )
       
class bp_geometry_conversion:
    @staticmethod
    def matrix_comparison(matrix_A, matrix_B):
        n = matrix_A.ndim
        m = matrix_B.ndim
        if n != m:
            return False
        bool_matrix = np.zeros((n,n))
        for i in range(0, n):
            for j in range(0, n):
                if matrix_A[i][j]!=matrix_B[i][j]:
                    bool_matrix[i][j]=1
        if bool_matrix.max()==0:
            return True
        else:
            return False
    
    @staticmethod
    def ROT_EULER_ZYZ(angle1, angle2, angle3):
        '''
        Rotation Matrix in the ZYZ notation such that Z(angle1)Y(angle2)Z(angle3)
        '''
        MATRIX = np.array([[(np.cos(angle1)*np.cos(angle2)*np.cos(angle3))-(np.sin(angle1)*np.sin(angle3)), (-1*np.sin(angle1)*np.cos(angle3))-(np.cos(angle1)*np.cos(angle2)*np.sin(angle3)), np.cos(angle1)*np.sin(angle2)],
                           [(np.sin(angle1)*np.cos(angle2)*np.cos(angle3))+(np.cos(angle1)*np.sin(angle3)),    (np.cos(angle1)*np.cos(angle3))-(np.sin(angle1)*np.cos(angle2)*np.sin(angle3)), np.sin(angle1)*np.sin(angle2)],
                           [                                            (-1*np.sin(angle2)*np.cos(angle3)),                                                   (np.sin(angle2)*np.sin(angle3)),                np.cos(angle2)]
                          ])
        return MATRIX
        
    @staticmethod
    def ROT_ANGLE_UNITVEC(angle, vector):
        if len(vector) != 3:
            return "-!- Error: Improperly formatted vector. Check input."
        else:
            C = np.cos(angle)
            S = np.sin(angle)
            u1 = vector[0]
            u2 = vector[1]
            u3 = vector[2]
            MATRIX = np.array([[     C+((1-C)*u1*u1), ((1-C)*u1*u2)-(u3*S), ((1-C)*u1*u3)+(u2*S)],
                               [((1-C)*u1*u2)+(u3*S),      C+((1-C)*u2*u2), ((1-C)*u2*u3)-(u1*S)],
                               [((1-C)*u1*u3)-(u2*S), ((1-C)*u2*u3)+(u1*S),      C+((1-C)*u3*u3)]
                              ])
            return MATRIX

    @staticmethod
    def frames_to_steppar(FRAME1, FRAME2):
        '''
        From two reference frames, generate the shift, slide, rise, tilt, roll, and twist step parameters.
        '''
        # Get Rotation Matrix
        frame1  = bp_geometry.frame_format(FRAME1)
        basis1  = frame1[[1,2,3]].T
        basis1  = bp_geometry.gram_schmidt_n3(basis1[0], basis1[1], basis1[2])
        frame2  = bp_geometry.frame_format(FRAME2)
        basis2  = frame2[[1,2,3]].T
        basis2  = bp_geometry.gram_schmidt_n3(basis2[0], basis2[1], basis2[2])
        Dij    = np.matmul(basis1.T, basis2)

        # Get Euler Angles and the gamma angle for mid-step frame
        kappa = np.arccos(Dij[2][2])
        zeta  = np.arctan2(Dij[1][2], Dij[0][2])
        eta   = np.arctan2(Dij[2][1], -1*Dij[2][0])
        if zeta+eta > np.pi:
            zeta = zeta-(2*np.pi)
        elif zeta+eta < -1*np.pi:
            zeta = zeta+(2*np.pi)
        gamma = (eta-zeta)/2

        # Get mid-step frame
        s_vector    = (frame2[0].T + frame1[0].T)/2
        S_rot_mat   = bp_geometry_conversion.ROT_EULER_ZYZ(zeta, kappa/2, gamma)
        S_frame_mat = np.matmul(basis1, S_rot_mat)

        # Finalize parameter collection
        r_vector = frame2[0].T - frame1[0].T
        SHIFT, SLIDE, RISE = np.dot(r_vector, S_frame_mat)
        TILT  = np.rad2deg( kappa*np.sin(gamma) )
        ROLL  = np.rad2deg( kappa*np.cos(gamma) )
        TWIST = np.rad2deg( eta + zeta )
        return SHIFT, SLIDE, RISE, TILT, ROLL, TWIST
    
    @staticmethod
    def steppar_to_frames(BPSTEP, BPFRAME):
        '''
        Make sure that the "BPSTEP" vector is a 1x6 vector in the order {shift, slide, rise, tilt, roll, twist}.
        Make sure PREVIOUS_FRAME contains both the position and 3x3 basis matrix.
        '''
        # Check if inputs are properly formatted
        STEP   = BPSTEP.copy()
        FRAME  = BPFRAME.copy()      
        
        if len(STEP)!=6:
            print("-!- Error: Need 6 parameters!")
        if len(FRAME) == 12:
            FRAME = bp_geometry.frame_format(FRAME)
        for i in range(3,6):
            STEP[i] = np.deg2rad(STEP[i])

        # Collect all Eular angles from base-pair step vector
        gamma = np.arctan2( STEP[3], STEP[4])
        kappa = np.sqrt( (STEP[3]**2) + (STEP[4]**2) )
        zeta  = ( STEP[5]/2 ) - gamma
        eta   = ( STEP[5]/2 ) + gamma

        # Get the rotational matrices
        Dsij = bp_geometry_conversion.ROT_EULER_ZYZ(zeta, kappa/2, gamma)
        Dij  = bp_geometry_conversion.ROT_EULER_ZYZ(zeta, kappa, eta)   

        # Get the step displacement vector and, from this, the new frame's position
        origin = FRAME[0]
        basis  = FRAME[[1,2,3]].T
        if bp_geometry_conversion.matrix_comparison(basis, basis.T) == False:
            basis  = bp_geometry.gram_schmidt_n3(basis[0], basis[1], basis[2])
        S_frame_mat = np.matmul(basis, Dsij )
        if bp_geometry_conversion.matrix_comparison(S_frame_mat, S_frame_mat.T) == False:
            S_frame_mat = bp_geometry.gram_schmidt_n3(S_frame_mat[0], S_frame_mat[1], S_frame_mat[2])
        r_vector = np.matmul( STEP[:3], S_frame_mat.T)

        # Compile new reference frame into 4x3 array
        NEW_POSITION = r_vector + origin
        NEW_BASIS    = np.matmul( basis, Dij ).T
        NEW_FRAME    = np.array([NEW_POSITION, NEW_BASIS[0], NEW_BASIS[1],NEW_BASIS[2]])
        return NEW_FRAME

# ---------------------------------------------------------------------------------------------------------------------

if __name__ == '__main__':
    main()

# ---------------------------------------------------------------------------------------------------------------------
