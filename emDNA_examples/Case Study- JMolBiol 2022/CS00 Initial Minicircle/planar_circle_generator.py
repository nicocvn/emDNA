#! /usr/bin/python3

### Script that generates a planar circle using the analytical function of sines and cosines
### This includes calculating the step params, convert to reference frames, add global frame as the new last base pair, converting back to step params, and output X.par file
### Script Author: Robert Young, Rutgers University, 2021
###
 
import os, math, argparse
import numpy as np
import pandas as pd
path = os.getcwd()

# --- CLI goal: 
# $ python3 SCRIPT.py -l       ... -r     ... -h            ... -s    ... -o       ...
# $ python3 SCRIPT.py --length ... --rise ... --bp-per-turn ... --seq ... --output-name ...

parser = argparse.ArgumentParser(prog="Planar Circle Generator",
                                 description="Generate a 3DNA-formatted parameter file associated with a planar circle of DNA using trigonometric functions.\nCode Generated by Robert Young, Rutgers University, 2021\n", 
                                 epilog="Mathematics citation: TBA.\nCode Generated by Robert Young, Rutgers University, 2021\n")
parser.add_argument('--length', '-l', action='store', 
                    type=int, required=True, dest="length", 
                    help="Length of DNA\n")
parser.add_argument('--seq','-s', action='store',
                    type=argparse.FileType('r'), default=None, dest="sequence", 
                    help="Reads a text file that contains the base pair sequence (default is a string of A residues that spans the specified length).\nAcceptable formats include text files with either a single line of the capitalized bases in sequence with no spaces or a sequence that has been copied from PubMed.\nEnsure that the sequence document does not contain non-sequence information (e.g. header, gene name(s), errata).\n")
parser.add_argument('--rise','-r', action='store',
                    type=float, default=3.40000, dest="rise", 
                    help="Rise displacement between successive base pairs (default=3.4-Angstrom, for B-DNA)\n")
parser.add_argument('--bp-per-turn','-h', action='store',
                    type=float, default=10.5, dest="bases_per_turn", 
                    help="Number of base pairs in a helical turn (default=10.5)\n")
parser.add_argument('--output-name','-o', action='store',
                    type=str, default="pcirc", dest="filename", 
                    help="Output name of parameter file (default=pcirc).\n-!- File extension has already been set to .par\n")
args= parser.parse_args()


# --- MAIN ------------------------------------------------------------------------------------------------------------
def main():
    if args.sequence == None:
        SEQ = 'A'*args.length
    else:
        SEQ = sequence_input_format(args.sequence)

    if args.length != len(SEQ):
        print("\n-!- Error: Circle length (N="+str(args.length)+") does not match sequence length (N="+str(len(SEQ))+").\nMake sure the length of the desired circle matches the sequence length.\n")
        
    else:
        DF  = planar_circle(args.length, args.rise, args.bases_per_turn)
        DF2 = dataframe_pars_to_frames(DF)
        DF2 = circular_dataframe(DF2)
        DF3 = dataframe_frames_to_pars(DF2)
        params_writer(DF3, SEQ, args.filename)
        del DF, DF2, DF3


# --- SCRIPT STEP-BY-STEP TASK LIST -----------------------------------------------------------------------------------
# Step 0: Check sequence input file
def sequence_input_format(DATAFILE):
    DATA = args.sequence.readlines()
    DATA = [i.rstrip('\n').replace(' ', '').upper() for i in DATA]
    STRING = ''
    for line in DATA:
        STRING += line
    return STRING

# Step 1: calculate rotational base-pair step parameters
def planar_circle(length, rise, bases_per_turn):
    """
    - length:         The length of the desired DNA construct
    - rise:           Vertical displacement between base pairs; for B-DNA, use 3.400-Angstroms
    - bases_per_turn: The number of bases for 1 helical turn of DNA. This will be used for rotational Twist.
    * NOTE: if length / bases_per_turn (the linking number) is NOT an integer value, the ends of the circle will not smoothly connect
    - dna_sequence:   Desired nucleotide sequence; default (found in code) will be a coding strand of only adenine residues
    return a pandas dataframe of shift, slide, rise, tilt, roll, twist values
    """
    DELTA     = 360/length # The bending angle at each step along circle
    TWIST_DEG = 360/bases_per_turn
    TWIST_RAD = np.deg2rad(TWIST_DEG)
    titles = ['shift','slide','rise','tilt','roll','twist']
    
    DATAFRAME = pd.DataFrame(columns=[i for i in titles], index=[i for i in range(length)])
    DATAFRAME[['shift','slide']]=0.00000
    for i in range(length):
        if i == 0:
            DATAFRAME.at[i, ['rise','tilt','roll','twist']]=0.00000
        else:
            DATAFRAME.at[i, 'rise']  = round(float(rise), 5)
            DATAFRAME.at[i, 'twist'] = round(float(TWIST_DEG), 5)
            
            DATAFRAME.at[i, 'tilt'] = round(float(DELTA*np.sin(i*TWIST_RAD)), 5)
            DATAFRAME.at[i, 'roll'] = round(float(DELTA*np.cos(i*TWIST_RAD)), 5)
            
    del DELTA, TWIST_DEG, TWIST_RAD, titles
    return DATAFRAME


# Step 2: convert parameters to reference frames
def dataframe_pars_to_frames(DATAFRAME):
    rf_titles=['ox','oy','oz','d11','d12','d13','d21','d22','d23','d31','d32','d33']
    DATAFRAME2 = pd.DataFrame(columns=[i for i in rf_titles], index=[i for i in range(len(DATAFRAME))])
    DATAFRAME2.at[0]=[0.,0.,0.,1.,0.,0.,0.,1.,0.,0.,0.,1.]
    
    for i in range(1, len(DATAFRAME)):
        DATAFRAME2.at[i]=bp_geometry_conversion.steppar_to_frames(DATAFRAME.loc[[i]].to_numpy()[0], DATAFRAME2.loc[[i-1]].to_numpy()[0]).flatten()    
    del rf_titles
    return DATAFRAME2

# Step 3: refframe[first] = refframe[last]
def circular_dataframe(DATAFRAME):
    return DATAFRAME.append(DATAFRAME.iloc[0], ignore_index=True).reset_index(drop=True)

# Step 4: convert reference frames to parameters
def dataframe_frames_to_pars(DATAFRAME):
    pars_titles = ['shift','slide','rise','tilt','roll','twist']
    DATAFRAME2 = pd.DataFrame(columns=[i for i in pars_titles], index=[i for i in range(len(DATAFRAME))])
    DATAFRAME2.at[0]=0.
    
    for i in range(1, len(DATAFRAME)):
        DATAFRAME2.at[i]=bp_geometry_conversion.frames_to_steppar(DATAFRAME.loc[[i-1]].to_numpy()[0], DATAFRAME.loc[[i]].to_numpy()[0])
    DATAFRAME2 = DATAFRAME2.astype('float')
    del pars_titles
    return DATAFRAME2

# Step 5: output X.par file
def params_writer(DATAFRAME, SEQUENCE, OUTPUTNAME):
    '''
    Needs a 2 line header >'{:>4}'.format(str(len(PARAM_COLLECTION)))+" # base pairs\n  0 # ***local base-pair & step parameters***\n
    line format > {seq:<4} {bp1:>9} {bp2:>9} {bp3:>9} {bp4:>9} {bp5:>9} {bp6:>9} {bps1:>9} {bps2:>9} {bps3:>9} {bps4:>9} {bps5:>9} {bps6:>9}
    first line of this format must be column titles: '#','Shear','Stretch','Stagger','Buckle','Prop-Tw','Opening','Shift','Slide','Rise','Tilt','Roll','Twist'
    '''        
    PARAM_COLLECTION = DATAFRAME.to_numpy()
    SEQ = SEQUENCE+SEQUENCE[0:1]
    BPDICT={'A':'A-T', 'T':'T-A','C':'C-G','G':'G-C'}
    if len(PARAM_COLLECTION)!= len(SEQ):
        print("FAILED")
        
    else:
        with open(OUTPUTNAME+'.par', 'w') as outfile:
            outfile.write('{}'.format(str(len(PARAM_COLLECTION)-1))+" # base pairs\n    0 # ***local base-pair & step parameters***\n")
            outfile.write('{:<7} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10} {:>10}\n'.format('#','Shear','Stretch','Stagger','Buckle','Prop-Tw','Opening','Shift','Slide','Rise','Tilt','Roll','Twist'))

            for i in range(len(PARAM_COLLECTION)):
                outfile.write('{seq:<7} {bp1:>10} {bp2:>10} {bp3:>10} {bp4:>10} {bp5:>10} {bp6:>10} {bps1:>10} {bps2:>10} {bps3:>10} {bps4:>10} {bps5:>10} {bps6:>10}\n'.format(
                seq = BPDICT[SEQ[i:i+1]], 
                bp1 = 0.0000, bp2=0.0000,   bp3=0.0000, 
                bp4 = 0.0000, bp5=0.0000,   bp6=0.0000, 
                bps1= round(PARAM_COLLECTION[i][0], 5), 
                bps2= round(PARAM_COLLECTION[i][1], 5),
                bps3= round(PARAM_COLLECTION[i][2], 5), 
                bps4= round(PARAM_COLLECTION[i][3], 5),
                bps5= round(PARAM_COLLECTION[i][4], 5),
                bps6= round(PARAM_COLLECTION[i][5], 5)
                ))
    del BPDICT, PARAM_COLLECTION, SEQ
    return


# ---------------------------------------------------------------------------------------------------------------------
# --- Standard Libary of Mathematics Definitions and Classes ----------------------------------------------------------
# ---------------------------------------------------------------------------------------------------------------------
        
GLOBAL_O = np.array([0.0, 0.0, 0.0])
GLOBAL_X = np.array([1.0, 0.0, 0.0])
GLOBAL_Y = np.array([0.0, 1.0, 0.0])
GLOBAL_Z = np.array([0.0, 0.0, 1.0])
GLOBAL_FRAME = [GLOBAL_O, [GLOBAL_X, GLOBAL_Y, GLOBAL_Z]]

class bp_geometry:
    #@staticmethod
    #def           

    @staticmethod
    def frame_format(FRAME):
        '''
        Turn a 1x12 array, or flattened matrix, from reference frames into a 4x3 vector, where:
        - top 1x3 is the origin
        - bottom 3x3 is the transpose of the basis vector
        '''
        if len(FRAME) != 12:
            return "-!- Error: Improperly formatted data. Check input."
        else:
            return np.array([FRAME[[0,1,2]],
                             FRAME[[3,4,5]], 
                             FRAME[[6,7,8]], 
                             FRAME[[9,10,11]]], dtype=float)    
    
    @staticmethod
    def norm_vec(vector):
        return vector/np.linalg.norm(vector)
    
    @staticmethod
    def gram_schmidt_n3(vector1, vector2, vector3):
        VECTOR1 = bp_geometry.norm_vec(vector1)
        VECTOR2 = bp_geometry.norm_vec(vector2 - np.dot(VECTOR1, vector2)*VECTOR1)
        VECTOR3 = bp_geometry.norm_vec(vector3 - np.dot(VECTOR1, vector3)*VECTOR1 - np.dot(VECTOR2, vector3)*VECTOR2)
        return np.array([VECTOR1, VECTOR2, VECTOR3])

    @staticmethod
    def vec_distance(vector):
        if len(vector) == 2:
            return np.sqrt(vector[0]**2 + vector[1]**2)
        elif len(vector) == 3:
            return np.sqrt(vector[0]**2 + vector[1]**2 + vector[2]**2)

    @staticmethod
    def vector_dot(vector1, vector2):
        return np.dot(vector1, vector2)/((np.linalg.norm(vector1))*(np.linalg.norm(vector2)))

    @staticmethod
    def vector_cross(vector1, vector2):
        '''Returns a vector of same dim as vector1 and vector2'''
        return bp_geometry.norm_vec(np.cross(vector1, 
                                             vector2))

    @staticmethod
    def vecvec_angle(vector1, vector2):
        '''Returns an angle in radians'''
        return np.arccos( np.dot(bp_geometry.norm_vec(vector1), 
                                 bp_geometry.norm_vec(vector2) ) )

    @staticmethod
    def positions_angle(positionvector1, positionvector2, positionvector3):
        '''Returns an angle in radians'''
        vec1 = bp_geometry.norm_vec(positionvector1 - positionvector2)
        vec2 = bp_geometry.norm_vec(positionvector3 - positionvector2)
        return np.arccos( np.dot(vec1, vec2) )

    @staticmethod
    def plane_normal(point1, point2, point3):
        return bp_geometry.norm_vec(np.cross(bp_geometry.norm_vec(point2 - point1),
                                             bp_geometry.norm_vec(point3 - point1)))

    @staticmethod
    def plane_projection(planenormal, vector):
        return bp_geometry.norm_vec(vector - np.dot(vector, planenormal)*planenormal)

    @staticmethod
    def vecpln_angle(vector, planenormal):
        '''Returns an angle in radians'''
        return np.arcsin( np.dot(bp_geometry.norm_vec(vector),
                                 bp_geometry.norm_vec(planenormal) ) )

    @staticmethod
    def plane_angles(planenormal1, planenormal2):
        '''Returns an angle in radians'''
        vecA = -1*(bp_geometry.norm_vec(planenormal1))
        vecB = bp_geometry.norm_vec(planenormal2)
        return np.arccos( np.dot(vecA, vecB) )
       
class bp_geometry_conversion:
    @staticmethod
    def matrix_comparison(matrix_A, matrix_B):
        n = matrix_A.ndim
        m = matrix_B.ndim
        if n != m:
            return False
        bool_matrix = np.zeros((n,n))
        for i in range(0, n):
            for j in range(0, n):
                if matrix_A[i][j]!=matrix_B[i][j]:
                    bool_matrix[i][j]=1
        if bool_matrix.max()==0:
            return True
        else:
            return False
    
    @staticmethod
    def ROT_EULER_ZYZ(angle1, angle2, angle3):
        '''
        Rotation Matrix in the ZYZ notation such that Z(angle1)Y(angle2)Z(angle3)
        '''
        MATRIX = np.array([[(np.cos(angle1)*np.cos(angle2)*np.cos(angle3))-(np.sin(angle1)*np.sin(angle3)), (-1*np.sin(angle1)*np.cos(angle3))-(np.cos(angle1)*np.cos(angle2)*np.sin(angle3)), np.cos(angle1)*np.sin(angle2)],
                           [(np.sin(angle1)*np.cos(angle2)*np.cos(angle3))+(np.cos(angle1)*np.sin(angle3)),    (np.cos(angle1)*np.cos(angle3))-(np.sin(angle1)*np.cos(angle2)*np.sin(angle3)), np.sin(angle1)*np.sin(angle2)],
                           [                                            (-1*np.sin(angle2)*np.cos(angle3)),                                                   (np.sin(angle2)*np.sin(angle3)),                np.cos(angle2)]
                          ])
        return MATRIX
        
    @staticmethod
    def ROT_ANGLE_UNITVEC(angle, vector):
        if len(vector) != 3:
            return "-!- Error: Improperly formatted vector. Check input."
        else:
            C = np.cos(angle)
            S = np.sin(angle)
            u1 = vector[0]
            u2 = vector[1]
            u3 = vector[2]
            MATRIX = np.array([[     C+((1-C)*u1*u1), ((1-C)*u1*u2)-(u3*S), ((1-C)*u1*u3)+(u2*S)],
                               [((1-C)*u1*u2)+(u3*S),      C+((1-C)*u2*u2), ((1-C)*u2*u3)-(u1*S)],
                               [((1-C)*u1*u3)-(u2*S), ((1-C)*u2*u3)+(u1*S),      C+((1-C)*u3*u3)]
                              ])
            return MATRIX

    @staticmethod
    def frames_to_steppar(FRAME1, FRAME2):
        '''
        From two reference frames, generate the shift, slide, rise, tilt, roll, and twist step parameters.
        '''
        # Get Rotation Matrix
        frame1  = bp_geometry.frame_format(FRAME1)
        basis1  = frame1[[1,2,3]].T
        basis1  = bp_geometry.gram_schmidt_n3(basis1[0], basis1[1], basis1[2])
        frame2  = bp_geometry.frame_format(FRAME2)
        basis2  = frame2[[1,2,3]].T
        basis2  = bp_geometry.gram_schmidt_n3(basis2[0], basis2[1], basis2[2])
        Dij    = np.matmul(basis1.T, basis2)

        # Get Euler Angles and the gamma angle for mid-step frame
        kappa = np.arccos(Dij[2][2])
        zeta  = np.arctan2(Dij[1][2], Dij[0][2])
        eta   = np.arctan2(Dij[2][1], -1*Dij[2][0])
        if zeta+eta > np.pi:
            zeta = zeta-(2*np.pi)
        elif zeta+eta < -1*np.pi:
            zeta = zeta+(2*np.pi)
        gamma = (eta-zeta)/2

        # Get mid-step frame
        s_vector    = (frame2[0].T + frame1[0].T)/2
        S_rot_mat   = bp_geometry_conversion.ROT_EULER_ZYZ(zeta, kappa/2, gamma)
        S_frame_mat = np.matmul(basis1, S_rot_mat)

        # Finalize parameter collection
        r_vector = frame2[0].T - frame1[0].T
        SHIFT, SLIDE, RISE = np.dot(r_vector, S_frame_mat)
        TILT  = np.rad2deg( kappa*np.sin(gamma) )
        ROLL  = np.rad2deg( kappa*np.cos(gamma) )
        TWIST = np.rad2deg( eta + zeta )
        return SHIFT, SLIDE, RISE, TILT, ROLL, TWIST
    
    @staticmethod
    def steppar_to_frames(BPSTEP, BPFRAME):
        '''
        Make sure that the "BPSTEP" vector is a 1x6 vector in the order {shift, slide, rise, tilt, roll, twist}.
        Make sure PREVIOUS_FRAME contains both the position and 3x3 basis matrix.
        '''
        # Check if inputs are properly formatted
        STEP   = BPSTEP.copy()
        FRAME  = BPFRAME.copy()      
        
        if len(STEP)!=6:
            print("-!- Error: Need 6 parameters!")
        if len(FRAME) == 12:
            FRAME = bp_geometry.frame_format(FRAME)
        for i in range(3,6):
            STEP[i] = np.deg2rad(STEP[i])

        # Collect all Eular angles from base-pair step vector
        gamma = np.arctan2( STEP[3], STEP[4])
        kappa = np.sqrt( (STEP[3]**2) + (STEP[4]**2) )
        zeta  = ( STEP[5]/2 ) - gamma
        eta   = ( STEP[5]/2 ) + gamma

        # Get the rotational matrices
        Dsij = bp_geometry_conversion.ROT_EULER_ZYZ(zeta, kappa/2, gamma)
        Dij  = bp_geometry_conversion.ROT_EULER_ZYZ(zeta, kappa, eta)   

        # Get the step displacement vector and, from this, the new frame's position
        origin = FRAME[0]
        basis  = FRAME[[1,2,3]].T
        if bp_geometry_conversion.matrix_comparison(basis, basis.T) == False:
            basis  = bp_geometry.gram_schmidt_n3(basis[0], basis[1], basis[2])
        S_frame_mat = np.matmul(basis, Dsij )
        if bp_geometry_conversion.matrix_comparison(S_frame_mat, S_frame_mat.T) == False:
            S_frame_mat = bp_geometry.gram_schmidt_n3(S_frame_mat[0], S_frame_mat[1], S_frame_mat[2])
        r_vector = np.matmul( STEP[:3], S_frame_mat.T)

        # Compile new reference frame into 4x3 array
        NEW_POSITION = r_vector + origin
        NEW_BASIS    = np.matmul( basis, Dij ).T
        NEW_FRAME    = np.array([NEW_POSITION, NEW_BASIS[0], NEW_BASIS[1],NEW_BASIS[2]])
        return NEW_FRAME

# ---------------------------------------------------------------------------------------------------------------------

if __name__ == '__main__':
    main()

# ---------------------------------------------------------------------------------------------------------------------
